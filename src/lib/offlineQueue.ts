import { initDb } from "./indexedDb";
import axios from "./axios";

export interface QueueItem {
  id?: number; // Auto-generated by IndexedDB
  url: string;
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  data?: any;
  headers?: Record<string, string>;
  timestamp: number;
  retryCount: number;
  status: "pending" | "processing" | "failed" | "completed";
}

// Global flag to prevent concurrent processing
let isProcessing = false;

/**
 * Add a request to the offline queue
 * Prevents duplicates by checking if similar request already exists
 */
export const addToQueue = async (
  url: string,
  method: QueueItem["method"],
  data?: any,
  headers?: Record<string, string>
): Promise<void> => {
  const db = await initDb();

  // Check for duplicate pending requests
  const existingItems = await db.getAll("offline-queue");
  const duplicate = existingItems.find(
    (item) =>
      item.url === url &&
      item.method === method &&
      item.status === "pending" &&
      JSON.stringify(item.data) === JSON.stringify(data)
  );

  if (duplicate) {
    console.log("‚ö†Ô∏è Duplicate request detected, skipping:", { method, url });
    return;
  }

  const queueItem: QueueItem = {
    url,
    method,
    data,
    headers,
    timestamp: Date.now(),
    retryCount: 0,
    status: "pending",
  };

  await db.add("offline-queue", queueItem);
  console.log("üì• Added to offline queue:", { method, url });
};

/**
 * Get all pending queue items
 */
export const getQueueItems = async (): Promise<QueueItem[]> => {
  const db = await initDb();
  const items = await db.getAll("offline-queue");
  return items.filter((item) => item.status === "pending");
};

/**
 * Get count of pending items
 */
export const getQueueCount = async (): Promise<number> => {
  const items = await getQueueItems();
  return items.length;
};

/**
 * Process all pending queue items
 * Prevents concurrent execution using global flag
 */
export const processQueue = async (): Promise<{
  success: number;
  failed: number;
}> => {
  // Prevent concurrent processing
  if (isProcessing) {
    console.log("‚è≥ Queue is already being processed, skipping...");
    return { success: 0, failed: 0 };
  }

  isProcessing = true;

  try {
    const db = await initDb();
    const pendingItems = await getQueueItems();

    if (pendingItems.length === 0) {
      console.log("‚úÖ Queue is empty, nothing to sync");
      return { success: 0, failed: 0 };
    }

    console.log(`üîÑ Processing ${pendingItems.length} queued requests...`);

    let successCount = 0;
    let failedCount = 0;

    for (const item of pendingItems) {
      try {
        // Update status to processing
        await db.put("offline-queue", { ...item, status: "processing" });

        // Make the actual request
        await axios({
          url: item.url,
          method: item.method,
          data: item.data,
          headers: item.headers,
        });

        // Remove from queue on success
        await db.delete("offline-queue", item.id!);
        successCount++;
        console.log(`‚úÖ Synced: ${item.method} ${item.url}`);

        // Add small delay to ensure different timestamps on backend
        // This prevents issues with ordering when multiple inspections are created
        if (pendingItems.indexOf(item) < pendingItems.length - 1) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      } catch (error) {
        failedCount++;
        console.error(`‚ùå Failed to sync: ${item.method} ${item.url}`, error);

        // Update retry count and status
        const updatedItem = {
          ...item,
          retryCount: item.retryCount + 1,
          status: item.retryCount >= 3 ? "failed" : "pending",
        } as QueueItem;

        await db.put("offline-queue", updatedItem);
      }
    }

    console.log(
      `üéØ Queue processed: ${successCount} success, ${failedCount} failed`
    );
    return { success: successCount, failed: failedCount };
  } finally {
    // Always reset the flag
    isProcessing = false;
  }
};

/**
 * Clear all completed or failed items
 */
export const clearCompletedQueue = async (): Promise<void> => {
  const db = await initDb();
  const allItems = await db.getAll("offline-queue");
  const toDelete = allItems.filter(
    (item) => item.status === "completed" || item.status === "failed"
  );

  for (const item of toDelete) {
    await db.delete("offline-queue", item.id!);
  }

  console.log(
    `üóëÔ∏è Cleared ${toDelete.length} completed/failed items from queue`
  );
};

/**
 * Clear entire queue (use with caution)
 */
export const clearAllQueue = async (): Promise<void> => {
  const db = await initDb();
  await db.clear("offline-queue");
  console.log("üóëÔ∏è Cleared entire offline queue");
};
